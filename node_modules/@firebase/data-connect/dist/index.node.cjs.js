'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

<<<<<<< HEAD
=======
var tslib = require('tslib');
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
var util = require('@firebase/util');
var logger$1 = require('@firebase/logger');
var app = require('@firebase/app');
var component = require('@firebase/component');

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
const Code = {
=======
var Code = {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    OTHER: 'other',
    ALREADY_INITIALIZED: 'already-initialized',
    NOT_INITIALIZED: 'not-initialized',
    NOT_SUPPORTED: 'not-supported',
    INVALID_ARGUMENT: 'invalid-argument',
    PARTIAL_ERROR: 'partial-error',
    UNAUTHORIZED: 'unauthorized'
};
/** An error returned by a DataConnect operation. */
<<<<<<< HEAD
class DataConnectError extends util.FirebaseError {
    constructor(code, message) {
        super(code, message);
        /** @internal */
        this.name = 'DataConnectError';
        // Ensure the instanceof operator works as expected on subclasses of Error.
        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types
        // and https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget
        Object.setPrototypeOf(this, DataConnectError.prototype);
    }
    /** @internal */
    toString() {
        return `${this.name}[code=${this.code}]: ${this.message}`;
    }
}
/** An error returned by a DataConnect operation. */
class DataConnectOperationError extends DataConnectError {
    /** @hideconstructor */
    constructor(message, response) {
        super(Code.PARTIAL_ERROR, message);
        /** @internal */
        this.name = 'DataConnectOperationError';
        this.response = response;
    }
}
=======
var DataConnectError = /** @class */ (function (_super) {
    tslib.__extends(DataConnectError, _super);
    /** @hideconstructor */
    function DataConnectError(
    /**
     * The backend error code associated with this error.
     */
    code, 
    /**
     * A custom error description.
     */
    message) {
        var _this = _super.call(this, code, message) || this;
        _this.code = code;
        _this.message = message;
        // HACK: We write a toString property directly because Error is not a real
        // class and so inheritance does not work correctly. We could alternatively
        // do the same "back-door inheritance" trick that FirebaseError does.
        _this.toString = function () { return "".concat(_this.name, ": [code=").concat(_this.code, "]: ").concat(_this.message); };
        return _this;
    }
    return DataConnectError;
}(util.FirebaseError));
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The semver (www.semver.org) version of the SDK. */
<<<<<<< HEAD
let SDK_VERSION = '';
=======
var SDK_VERSION = '';
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
/**
 * SDK_VERSION should be set before any database instance is created
 * @internal
 */
function setSDKVersion(version) {
    SDK_VERSION = version;
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
const logger = new logger$1.Logger('@firebase/data-connect');
=======
var logger = new logger$1.Logger('@firebase/data-connect');
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
function setLogLevel(logLevel) {
    logger.setLogLevel(logLevel);
}
function logDebug(msg) {
<<<<<<< HEAD
    logger.debug(`DataConnect (${SDK_VERSION}): ${msg}`);
}
function logError(msg) {
    logger.error(`DataConnect (${SDK_VERSION}): ${msg}`);
=======
    logger.debug("DataConnect (".concat(SDK_VERSION, "): ").concat(msg));
}
function logError(msg) {
    logger.error("DataConnect (".concat(SDK_VERSION, "): ").concat(msg));
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
const CallerSdkTypeEnum = {
    Base: 'Base', // Core JS SDK
    Generated: 'Generated', // Generated JS SDK
    TanstackReactCore: 'TanstackReactCore', // Tanstack non-generated React SDK
    GeneratedReact: 'GeneratedReact', // Tanstack non-generated Angular SDK
    TanstackAngularCore: 'TanstackAngularCore', // Tanstack non-generated Angular SDK
    GeneratedAngular: 'GeneratedAngular' // Generated Angular SDK
};

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let connectFetch = globalThis.fetch;
function initializeFetch(fetchImpl) {
    connectFetch = fetchImpl;
}
function getGoogApiClientValue(_isUsingGen, _callerSdkType) {
    let str = 'gl-js/ fire/' + SDK_VERSION;
    if (_callerSdkType !== CallerSdkTypeEnum.Base &&
        _callerSdkType !== CallerSdkTypeEnum.Generated) {
        str += ' js/' + _callerSdkType.toLowerCase();
    }
    else if (_isUsingGen || _callerSdkType === CallerSdkTypeEnum.Generated) {
        str += ' js/gen';
    }
    return str;
}
function dcFetch(url, body, { signal }, appId, accessToken, appCheckToken, _isUsingGen, _callerSdkType, _isUsingEmulator) {
    if (!connectFetch) {
        throw new DataConnectError(Code.OTHER, 'No Fetch Implementation detected!');
    }
    const headers = {
        'Content-Type': 'application/json',
        'X-Goog-Api-Client': getGoogApiClientValue(_isUsingGen, _callerSdkType)
=======
var connectFetch = globalThis.fetch;
function initializeFetch(fetchImpl) {
    connectFetch = fetchImpl;
}
function getGoogApiClientValue(_isUsingGen) {
    var str = 'gl-js/ fire/' + SDK_VERSION;
    if (_isUsingGen) {
        str += ' web/gen';
    }
    return str;
}
function dcFetch(url, body, _a, appId, accessToken, appCheckToken, _isUsingGen) {
    var _this = this;
    var signal = _a.signal;
    if (!connectFetch) {
        throw new DataConnectError(Code.OTHER, 'No Fetch Implementation detected!');
    }
    var headers = {
        'Content-Type': 'application/json',
        'X-Goog-Api-Client': getGoogApiClientValue(_isUsingGen)
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    };
    if (accessToken) {
        headers['X-Firebase-Auth-Token'] = accessToken;
    }
    if (appId) {
        headers['x-firebase-gmpid'] = appId;
    }
    if (appCheckToken) {
        headers['X-Firebase-AppCheck'] = appCheckToken;
    }
<<<<<<< HEAD
    const bodyStr = JSON.stringify(body);
    const fetchOptions = {
        body: bodyStr,
        method: 'POST',
        headers,
        signal
    };
    if (util.isCloudWorkstation(url) && _isUsingEmulator) {
        fetchOptions.credentials = 'include';
    }
    return connectFetch(url, fetchOptions)
        .catch(err => {
        throw new DataConnectError(Code.OTHER, 'Failed to fetch: ' + JSON.stringify(err));
    })
        .then(async (response) => {
        let jsonResponse = null;
        try {
            jsonResponse = await response.json();
        }
        catch (e) {
            throw new DataConnectError(Code.OTHER, JSON.stringify(e));
        }
        const message = getMessage(jsonResponse);
        if (response.status >= 400) {
            logError('Error while performing request: ' + JSON.stringify(jsonResponse));
            if (response.status === 401) {
                throw new DataConnectError(Code.UNAUTHORIZED, message);
            }
            throw new DataConnectError(Code.OTHER, message);
        }
        return jsonResponse;
    })
        .then(res => {
        if (res.errors && res.errors.length) {
            const stringified = JSON.stringify(res.errors);
            const response = {
                errors: res.errors,
                data: res.data
            };
            throw new DataConnectOperationError('DataConnect error while performing request: ' + stringified, response);
=======
    var bodyStr = JSON.stringify(body);
    logDebug("Making request out to ".concat(url, " with body: ").concat(bodyStr));
    return connectFetch(url, {
        body: bodyStr,
        method: 'POST',
        headers: headers,
        signal: signal
    })
        .catch(function (err) {
        throw new DataConnectError(Code.OTHER, 'Failed to fetch: ' + JSON.stringify(err));
    })
        .then(function (response) { return tslib.__awaiter(_this, void 0, void 0, function () {
        var jsonResponse, e_1, message;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    jsonResponse = null;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, response.json()];
                case 2:
                    jsonResponse = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    e_1 = _a.sent();
                    throw new DataConnectError(Code.OTHER, JSON.stringify(e_1));
                case 4:
                    message = getMessage(jsonResponse);
                    if (response.status >= 400) {
                        logError('Error while performing request: ' + JSON.stringify(jsonResponse));
                        if (response.status === 401) {
                            throw new DataConnectError(Code.UNAUTHORIZED, message);
                        }
                        throw new DataConnectError(Code.OTHER, message);
                    }
                    return [2 /*return*/, jsonResponse];
            }
        });
    }); })
        .then(function (res) {
        if (res.errors && res.errors.length) {
            var stringified = JSON.stringify(res.errors);
            logError('DataConnect error while performing request: ' + stringified);
            throw new DataConnectError(Code.OTHER, stringified);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        }
        return res;
    });
}
function getMessage(obj) {
    if ('message' in obj) {
        return obj.message;
    }
    return JSON.stringify(obj);
}

<<<<<<< HEAD
const name = "@firebase/data-connect";
const version = "0.3.11";
=======
var name = "@firebase/data-connect";
var version = "0.1.0";
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 * Abstraction around AppCheck's token fetching capabilities.
 */
<<<<<<< HEAD
class AppCheckTokenProvider {
    constructor(app$1, appCheckProvider) {
        this.appCheckProvider = appCheckProvider;
        if (app._isFirebaseServerApp(app$1) && app$1.settings.appCheckToken) {
            this.serverAppAppCheckToken = app$1.settings.appCheckToken;
        }
        this.appCheck = appCheckProvider?.getImmediate({ optional: true });
        if (!this.appCheck) {
            void appCheckProvider
                ?.get()
                .then(appCheck => (this.appCheck = appCheck))
                .catch();
        }
    }
    getToken() {
        if (this.serverAppAppCheckToken) {
            return Promise.resolve({ token: this.serverAppAppCheckToken });
        }
        if (!this.appCheck) {
            return new Promise((resolve, reject) => {
=======
var AppCheckTokenProvider = /** @class */ (function () {
    function AppCheckTokenProvider(appName_, appCheckProvider) {
        var _this = this;
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
            void (appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(function (appCheck) { return (_this.appCheck = appCheck); }).catch());
        }
    }
    AppCheckTokenProvider.prototype.getToken = function (forceRefresh) {
        var _this = this;
        if (!this.appCheck) {
            return new Promise(function (resolve, reject) {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
                // Support delayed initialization of FirebaseAppCheck. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // AppCheck and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
<<<<<<< HEAD
                setTimeout(() => {
                    if (this.appCheck) {
                        this.getToken().then(resolve, reject);
=======
                setTimeout(function () {
                    if (_this.appCheck) {
                        _this.getToken(forceRefresh).then(resolve, reject);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
<<<<<<< HEAD
        return this.appCheck.getToken();
    }
    addTokenChangeListener(listener) {
        void this.appCheckProvider
            ?.get()
            .then(appCheck => appCheck.addTokenListener(listener));
    }
}
=======
        return this.appCheck.getToken(forceRefresh);
    };
    AppCheckTokenProvider.prototype.addTokenChangeListener = function (listener) {
        var _a;
        void ((_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(function (appCheck) { return appCheck.addTokenListener(listener); }));
    };
    return AppCheckTokenProvider;
}());
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// @internal
<<<<<<< HEAD
class FirebaseAuthProvider {
    constructor(_appName, _options, _authProvider) {
=======
var FirebaseAuthProvider = /** @class */ (function () {
    function FirebaseAuthProvider(_appName, _options, _authProvider) {
        var _this = this;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        this._appName = _appName;
        this._options = _options;
        this._authProvider = _authProvider;
        this._auth = _authProvider.getImmediate({ optional: true });
        if (!this._auth) {
<<<<<<< HEAD
            _authProvider.onInit(auth => (this._auth = auth));
        }
    }
    getToken(forceRefresh) {
        if (!this._auth) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (this._auth) {
                        this.getToken(forceRefresh).then(resolve, reject);
=======
            _authProvider.onInit(function (auth) { return (_this._auth = auth); });
        }
    }
    FirebaseAuthProvider.prototype.getToken = function (forceRefresh) {
        var _this = this;
        if (!this._auth) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    if (_this._auth) {
                        _this.getToken(forceRefresh).then(resolve, reject);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
<<<<<<< HEAD
        return this._auth.getToken(forceRefresh).catch(error => {
=======
        return this._auth.getToken(forceRefresh).catch(function (error) {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            if (error && error.code === 'auth/token-not-initialized') {
                logDebug('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
            }
            else {
                logError('Error received when attempting to retrieve token: ' +
                    JSON.stringify(error));
                return Promise.reject(error);
            }
        });
<<<<<<< HEAD
    }
    addTokenChangeListener(listener) {
        this._auth?.addAuthTokenListener(listener);
    }
    removeTokenChangeListener(listener) {
        this._authProvider
            .get()
            .then(auth => auth.removeAuthTokenListener(listener))
            .catch(err => logError(err));
    }
}
=======
    };
    FirebaseAuthProvider.prototype.addTokenChangeListener = function (listener) {
        var _a;
        (_a = this._auth) === null || _a === void 0 ? void 0 : _a.addAuthTokenListener(listener);
    };
    FirebaseAuthProvider.prototype.removeTokenChangeListener = function (listener) {
        this._authProvider
            .get()
            .then(function (auth) { return auth.removeAuthTokenListener(listener); })
            .catch(function (err) { return logError(err); });
    };
    return FirebaseAuthProvider;
}());
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
const QUERY_STR = 'query';
const MUTATION_STR = 'mutation';
const SOURCE_SERVER = 'SERVER';
const SOURCE_CACHE = 'CACHE';
=======
var QUERY_STR = 'query';
var MUTATION_STR = 'mutation';
var SOURCE_SERVER = 'SERVER';
var SOURCE_CACHE = 'CACHE';
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
let encoderImpl;
function setEncoder(encoder) {
    encoderImpl = encoder;
}
setEncoder(o => JSON.stringify(o));
=======
var encoderImpl;
function setEncoder(encoder) {
    encoderImpl = encoder;
}
setEncoder(function (o) { return JSON.stringify(o); });
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setIfNotExists(map, key, val) {
    if (!map.has(key)) {
        map.set(key, val);
    }
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getRefSerializer(queryRef, data, source) {
    return function toJSON() {
        return {
<<<<<<< HEAD
            data,
            refInfo: {
                name: queryRef.name,
                variables: queryRef.variables,
                connectorConfig: {
                    projectId: queryRef.dataConnect.app.options.projectId,
                    ...queryRef.dataConnect.getSettings()
                }
            },
            fetchTime: Date.now().toLocaleString(),
            source
        };
    };
}
class QueryManager {
    constructor(transport) {
        this.transport = transport;
        this._queries = new Map();
    }
    track(queryName, variables, initialCache) {
        const ref = {
            name: queryName,
            variables,
            refType: QUERY_STR
        };
        const key = encoderImpl(ref);
        const newTrackedQuery = {
            ref,
=======
            data: data,
            refInfo: {
                name: queryRef.name,
                variables: queryRef.variables,
                connectorConfig: tslib.__assign({ projectId: queryRef.dataConnect.app.options.projectId }, queryRef.dataConnect.getSettings())
            },
            fetchTime: Date.now().toLocaleString(),
            source: source
        };
    };
}
var QueryManager = /** @class */ (function () {
    function QueryManager(transport) {
        this.transport = transport;
        this._queries = new Map();
    }
    QueryManager.prototype.track = function (queryName, variables, initialCache) {
        var ref = {
            name: queryName,
            variables: variables,
            refType: QUERY_STR
        };
        var key = encoderImpl(ref);
        var newTrackedQuery = {
            ref: ref,
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            subscriptions: [],
            currentCache: initialCache || null,
            lastError: null
        };
        // @ts-ignore
        setIfNotExists(this._queries, key, newTrackedQuery);
        return this._queries.get(key);
<<<<<<< HEAD
    }
    addSubscription(queryRef, onResultCallback, onErrorCallback, initialCache) {
        const key = encoderImpl({
=======
    };
    QueryManager.prototype.addSubscription = function (queryRef, onResultCallback, onErrorCallback, initialCache) {
        var _this = this;
        var key = encoderImpl({
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            name: queryRef.name,
            variables: queryRef.variables,
            refType: QUERY_STR
        });
<<<<<<< HEAD
        const trackedQuery = this._queries.get(key);
        const subscription = {
            userCallback: onResultCallback,
            errCallback: onErrorCallback
        };
        const unsubscribe = () => {
            const trackedQuery = this._queries.get(key);
            trackedQuery.subscriptions = trackedQuery.subscriptions.filter(sub => sub !== subscription);
=======
        var trackedQuery = this._queries.get(key);
        var subscription = {
            userCallback: onResultCallback,
            errCallback: onErrorCallback
        };
        var unsubscribe = function () {
            var trackedQuery = _this._queries.get(key);
            trackedQuery.subscriptions = trackedQuery.subscriptions.filter(function (sub) { return sub !== subscription; });
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        };
        if (initialCache && trackedQuery.currentCache !== initialCache) {
            logDebug('Initial cache found. Comparing dates.');
            if (!trackedQuery.currentCache ||
                (trackedQuery.currentCache &&
                    compareDates(trackedQuery.currentCache.fetchTime, initialCache.fetchTime))) {
                trackedQuery.currentCache = initialCache;
            }
        }
        if (trackedQuery.currentCache !== null) {
<<<<<<< HEAD
            const cachedData = trackedQuery.currentCache.data;
=======
            var cachedData = trackedQuery.currentCache.data;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            onResultCallback({
                data: cachedData,
                source: SOURCE_CACHE,
                ref: queryRef,
                toJSON: getRefSerializer(queryRef, trackedQuery.currentCache.data, SOURCE_CACHE),
                fetchTime: trackedQuery.currentCache.fetchTime
            });
            if (trackedQuery.lastError !== null && onErrorCallback) {
                onErrorCallback(undefined);
            }
        }
        trackedQuery.subscriptions.push({
            userCallback: onResultCallback,
            errCallback: onErrorCallback,
<<<<<<< HEAD
            unsubscribe
        });
        if (!trackedQuery.currentCache) {
            logDebug(`No cache available for query ${queryRef.name} with variables ${JSON.stringify(queryRef.variables)}. Calling executeQuery.`);
            const promise = this.executeQuery(queryRef);
            // We want to ignore the error and let subscriptions handle it
            promise.then(undefined, err => { });
        }
        return unsubscribe;
    }
    executeQuery(queryRef) {
        if (queryRef.refType !== QUERY_STR) {
            throw new DataConnectError(Code.INVALID_ARGUMENT, `ExecuteQuery can only execute query operation`);
        }
        const key = encoderImpl({
=======
            unsubscribe: unsubscribe
        });
        if (!trackedQuery.currentCache) {
            logDebug("No cache available for query ".concat(queryRef.name, " with variables ").concat(JSON.stringify(queryRef.variables), ". Calling executeQuery."));
            var promise = this.executeQuery(queryRef);
            // We want to ignore the error and let subscriptions handle it
            promise.then(undefined, function (err) { });
        }
        return unsubscribe;
    };
    QueryManager.prototype.executeQuery = function (queryRef) {
        var key = encoderImpl({
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            name: queryRef.name,
            variables: queryRef.variables,
            refType: QUERY_STR
        });
<<<<<<< HEAD
        const trackedQuery = this._queries.get(key);
        const result = this.transport.invokeQuery(queryRef.name, queryRef.variables);
        const newR = result.then(res => {
            const fetchTime = new Date().toString();
            const result = {
                ...res,
                source: SOURCE_SERVER,
                ref: queryRef,
                toJSON: getRefSerializer(queryRef, res.data, SOURCE_SERVER),
                fetchTime
            };
            trackedQuery.subscriptions.forEach(subscription => {
=======
        var trackedQuery = this._queries.get(key);
        var result = this.transport.invokeQuery(queryRef.name, queryRef.variables);
        var newR = result.then(function (res) {
            var fetchTime = new Date().toString();
            var result = tslib.__assign(tslib.__assign({}, res), { source: SOURCE_SERVER, ref: queryRef, toJSON: getRefSerializer(queryRef, res.data, SOURCE_SERVER), fetchTime: fetchTime });
            trackedQuery.subscriptions.forEach(function (subscription) {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
                subscription.userCallback(result);
            });
            trackedQuery.currentCache = {
                data: res.data,
                source: SOURCE_CACHE,
<<<<<<< HEAD
                fetchTime
            };
            return result;
        }, err => {
            trackedQuery.lastError = err;
            trackedQuery.subscriptions.forEach(subscription => {
=======
                fetchTime: fetchTime
            };
            return result;
        }, function (err) {
            trackedQuery.lastError = err;
            trackedQuery.subscriptions.forEach(function (subscription) {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
                if (subscription.errCallback) {
                    subscription.errCallback(err);
                }
            });
            throw err;
        });
        return newR;
<<<<<<< HEAD
    }
    enableEmulator(host, port) {
        this.transport.useEmulator(host, port);
    }
}
function compareDates(str1, str2) {
    const date1 = new Date(str1);
    const date2 = new Date(str2);
=======
    };
    QueryManager.prototype.enableEmulator = function (host, port) {
        this.transport.useEmulator(host, port);
    };
    return QueryManager;
}());
function compareDates(str1, str2) {
    var date1 = new Date(str1);
    var date2 = new Date(str2);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    return date1.getTime() < date2.getTime();
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function urlBuilder(projectConfig, transportOptions) {
<<<<<<< HEAD
    const { connector, location, projectId: project, service } = projectConfig;
    const { host, sslEnabled, port } = transportOptions;
    const protocol = sslEnabled ? 'https' : 'http';
    const realHost = host || `firebasedataconnect.googleapis.com`;
    let baseUrl = `${protocol}://${realHost}`;
    if (typeof port === 'number') {
        baseUrl += `:${port}`;
=======
    var connector = projectConfig.connector, location = projectConfig.location, project = projectConfig.projectId, service = projectConfig.service;
    var host = transportOptions.host, sslEnabled = transportOptions.sslEnabled, port = transportOptions.port;
    var protocol = sslEnabled ? 'https' : 'http';
    var realHost = host || "firebasedataconnect.googleapis.com";
    var baseUrl = "".concat(protocol, "://").concat(realHost);
    if (typeof port === 'number') {
        baseUrl += ":".concat(port);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    }
    else if (typeof port !== 'undefined') {
        logError('Port type is of an invalid type');
        throw new DataConnectError(Code.INVALID_ARGUMENT, 'Incorrect type for port passed in!');
    }
<<<<<<< HEAD
    return `${baseUrl}/v1/projects/${project}/locations/${location}/services/${service}/connectors/${connector}`;
=======
    return "".concat(baseUrl, "/v1beta/projects/").concat(project, "/locations/").concat(location, "/services/").concat(service, "/connectors/").concat(connector);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
}
function addToken(url, apiKey) {
    if (!apiKey) {
        return url;
    }
<<<<<<< HEAD
    const newUrl = new URL(url);
=======
    var newUrl = new URL(url);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    newUrl.searchParams.append('key', apiKey);
    return newUrl.toString();
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
class RESTTransport {
    constructor(options, apiKey, appId, authProvider, appCheckProvider, transportOptions, _isUsingGen = false, _callerSdkType = CallerSdkTypeEnum.Base) {
=======
var RESTTransport = /** @class */ (function () {
    function RESTTransport(options, apiKey, appId, authProvider, appCheckProvider, transportOptions, _isUsingGen) {
        if (_isUsingGen === void 0) { _isUsingGen = false; }
        var _this = this;
        var _a, _b;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        this.apiKey = apiKey;
        this.appId = appId;
        this.authProvider = authProvider;
        this.appCheckProvider = appCheckProvider;
        this._isUsingGen = _isUsingGen;
<<<<<<< HEAD
        this._callerSdkType = _callerSdkType;
=======
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        this._host = '';
        this._location = 'l';
        this._connectorName = '';
        this._secure = true;
        this._project = 'p';
        this._accessToken = null;
        this._appCheckToken = null;
        this._lastToken = null;
<<<<<<< HEAD
        this._isUsingEmulator = false;
        // TODO(mtewani): Update U to include shape of body defined in line 13.
        this.invokeQuery = (queryName, body) => {
            const abortController = new AbortController();
            // TODO(mtewani): Update to proper value
            const withAuth = this.withRetry(() => dcFetch(addToken(`${this.endpointUrl}:executeQuery`, this.apiKey), {
                name: `projects/${this._project}/locations/${this._location}/services/${this._serviceName}/connectors/${this._connectorName}`,
                operationName: queryName,
                variables: body
            }, abortController, this.appId, this._accessToken, this._appCheckToken, this._isUsingGen, this._callerSdkType, this._isUsingEmulator));
            return withAuth;
        };
        this.invokeMutation = (mutationName, body) => {
            const abortController = new AbortController();
            const taskResult = this.withRetry(() => {
                return dcFetch(addToken(`${this.endpointUrl}:executeMutation`, this.apiKey), {
                    name: `projects/${this._project}/locations/${this._location}/services/${this._serviceName}/connectors/${this._connectorName}`,
                    operationName: mutationName,
                    variables: body
                }, abortController, this.appId, this._accessToken, this._appCheckToken, this._isUsingGen, this._callerSdkType, this._isUsingEmulator);
            });
            return taskResult;
=======
        // TODO(mtewani): Update U to include shape of body defined in line 13.
        this.invokeQuery = function (queryName, body) {
            var abortController = new AbortController();
            // TODO(mtewani): Update to proper value
            var withAuth = _this.withRetry(function () {
                return dcFetch(addToken("".concat(_this.endpointUrl, ":executeQuery"), _this.apiKey), {
                    name: "projects/".concat(_this._project, "/locations/").concat(_this._location, "/services/").concat(_this._serviceName, "/connectors/").concat(_this._connectorName),
                    operationName: queryName,
                    variables: body
                }, // TODO(mtewani): This is a patch, fix this.
                abortController, _this.appId, _this._accessToken, _this._appCheckToken, _this._isUsingGen);
            });
            return {
                then: withAuth.then.bind(withAuth),
                catch: withAuth.catch.bind(withAuth)
            };
        };
        this.invokeMutation = function (mutationName, body) {
            var abortController = new AbortController();
            var taskResult = _this.withRetry(function () {
                return dcFetch(addToken("".concat(_this.endpointUrl, ":executeMutation"), _this.apiKey), {
                    name: "projects/".concat(_this._project, "/locations/").concat(_this._location, "/services/").concat(_this._serviceName, "/connectors/").concat(_this._connectorName),
                    operationName: mutationName,
                    variables: body
                }, abortController, _this.appId, _this._accessToken, _this._appCheckToken, _this._isUsingGen);
            });
            return {
                then: taskResult.then.bind(taskResult),
                // catch: taskResult.catch.bind(taskResult),
                // finally: taskResult.finally.bind(taskResult),
                cancel: function () { return abortController.abort(); }
            };
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        };
        if (transportOptions) {
            if (typeof transportOptions.port === 'number') {
                this._port = transportOptions.port;
            }
            if (typeof transportOptions.sslEnabled !== 'undefined') {
                this._secure = transportOptions.sslEnabled;
            }
            this._host = transportOptions.host;
        }
<<<<<<< HEAD
        const { location, projectId: project, connector, service } = options;
=======
        var location = options.location, project = options.projectId, connector = options.connector, service = options.service;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        if (location) {
            this._location = location;
        }
        if (project) {
            this._project = project;
        }
        this._serviceName = service;
        if (!connector) {
            throw new DataConnectError(Code.INVALID_ARGUMENT, 'Connector Name required!');
        }
        this._connectorName = connector;
<<<<<<< HEAD
        this.authProvider?.addTokenChangeListener(token => {
            logDebug(`New Token Available: ${token}`);
            this._accessToken = token;
        });
        this.appCheckProvider?.addTokenChangeListener(result => {
            const { token } = result;
            logDebug(`New App Check Token Available: ${token}`);
            this._appCheckToken = token;
        });
    }
    get endpointUrl() {
        return urlBuilder({
            connector: this._connectorName,
            location: this._location,
            projectId: this._project,
            service: this._serviceName
        }, { host: this._host, sslEnabled: this._secure, port: this._port });
    }
    useEmulator(host, port, isSecure) {
        this._host = host;
        this._isUsingEmulator = true;
=======
        (_a = this.authProvider) === null || _a === void 0 ? void 0 : _a.addTokenChangeListener(function (token) {
            logDebug("New Token Available: ".concat(token));
            _this._accessToken = token;
        });
        (_b = this.appCheckProvider) === null || _b === void 0 ? void 0 : _b.addTokenChangeListener(function (result) {
            var token = result.token;
            logDebug("New App Check Token Available: ".concat(token));
            _this._appCheckToken = token;
        });
    }
    Object.defineProperty(RESTTransport.prototype, "endpointUrl", {
        get: function () {
            return urlBuilder({
                connector: this._connectorName,
                location: this._location,
                projectId: this._project,
                service: this._serviceName
            }, { host: this._host, sslEnabled: this._secure, port: this._port });
        },
        enumerable: false,
        configurable: true
    });
    RESTTransport.prototype.useEmulator = function (host, port, isSecure) {
        this._host = host;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        if (typeof port === 'number') {
            this._port = port;
        }
        if (typeof isSecure !== 'undefined') {
            this._secure = isSecure;
        }
<<<<<<< HEAD
    }
    onTokenChanged(newToken) {
        this._accessToken = newToken;
    }
    async getWithAuth(forceToken = false) {
        let starterPromise = new Promise(resolve => resolve(this._accessToken));
        if (this.appCheckProvider) {
            this._appCheckToken = (await this.appCheckProvider.getToken())?.token;
        }
        if (this.authProvider) {
            starterPromise = this.authProvider
                .getToken(/*forceToken=*/ forceToken)
                .then(data => {
                if (!data) {
                    return null;
                }
                this._accessToken = data.accessToken;
                return this._accessToken;
            });
        }
        else {
            starterPromise = new Promise(resolve => resolve(''));
        }
        return starterPromise;
    }
    _setLastToken(lastToken) {
        this._lastToken = lastToken;
    }
    withRetry(promiseFactory, retry = false) {
        let isNewToken = false;
        return this.getWithAuth(retry)
            .then(res => {
            isNewToken = this._lastToken !== res;
            this._lastToken = res;
            return res;
        })
            .then(promiseFactory)
            .catch(err => {
=======
    };
    RESTTransport.prototype.onTokenChanged = function (newToken) {
        this._accessToken = newToken;
    };
    RESTTransport.prototype.getWithAuth = function (forceToken) {
        var _a;
        if (forceToken === void 0) { forceToken = false; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var starterPromise, _b;
            var _this = this;
            return tslib.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        starterPromise = new Promise(function (resolve) {
                            return resolve(_this._accessToken);
                        });
                        if (!this.appCheckProvider) return [3 /*break*/, 2];
                        _b = this;
                        return [4 /*yield*/, this.appCheckProvider.getToken()];
                    case 1:
                        _b._appCheckToken = (_a = (_c.sent())) === null || _a === void 0 ? void 0 : _a.token;
                        _c.label = 2;
                    case 2:
                        if (this.authProvider) {
                            starterPromise = this.authProvider
                                .getToken(/*forceToken=*/ forceToken)
                                .then(function (data) {
                                if (!data) {
                                    return null;
                                }
                                _this._accessToken = data.accessToken;
                                return _this._accessToken;
                            });
                        }
                        else {
                            starterPromise = new Promise(function (resolve) { return resolve(''); });
                        }
                        return [2 /*return*/, starterPromise];
                }
            });
        });
    };
    RESTTransport.prototype._setLastToken = function (lastToken) {
        this._lastToken = lastToken;
    };
    RESTTransport.prototype.withRetry = function (promiseFactory, retry) {
        var _this = this;
        if (retry === void 0) { retry = false; }
        var isNewToken = false;
        return this.getWithAuth(retry)
            .then(function (res) {
            isNewToken = _this._lastToken !== res;
            _this._lastToken = res;
            return res;
        })
            .then(promiseFactory)
            .catch(function (err) {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            // Only retry if the result is unauthorized and the last token isn't the same as the new one.
            if ('code' in err &&
                err.code === Code.UNAUTHORIZED &&
                !retry &&
                isNewToken) {
                logDebug('Retrying due to unauthorized');
<<<<<<< HEAD
                return this.withRetry(promiseFactory, true);
            }
            throw err;
        });
    }
    _setCallerSdkType(callerSdkType) {
        this._callerSdkType = callerSdkType;
    }
}
=======
                return _this.withRetry(promiseFactory, true);
            }
            throw err;
        });
    };
    return RESTTransport;
}());
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * @param dcInstance Data Connect instance
 * @param mutationName name of mutation
 * @param variables variables to send with mutation
 * @returns `MutationRef`
 */
function mutationRef(dcInstance, mutationName, variables) {
    dcInstance.setInitialized();
<<<<<<< HEAD
    const ref = {
=======
    var ref = {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        dataConnect: dcInstance,
        name: mutationName,
        refType: MUTATION_STR,
        variables: variables
    };
    return ref;
}
/**
 * @internal
 */
<<<<<<< HEAD
class MutationManager {
    constructor(_transport) {
        this._transport = _transport;
        this._inflight = [];
    }
    executeMutation(mutationRef) {
        const result = this._transport.invokeMutation(mutationRef.name, mutationRef.variables);
        const withRefPromise = result.then(res => {
            const obj = {
                ...res, // Double check that the result is result.data, not just result
                source: SOURCE_SERVER,
                ref: mutationRef,
                fetchTime: Date.now().toLocaleString()
            };
            return obj;
        });
        this._inflight.push(result);
        const removePromise = () => (this._inflight = this._inflight.filter(promise => promise !== result));
        result.then(removePromise, removePromise);
        return withRefPromise;
    }
}
=======
var MutationManager = /** @class */ (function () {
    function MutationManager(_transport) {
        this._transport = _transport;
        this._inflight = [];
    }
    MutationManager.prototype.executeMutation = function (mutationRef) {
        var _this = this;
        var result = this._transport.invokeMutation(mutationRef.name, mutationRef.variables);
        var withRefPromise = result.then(function (res) {
            var obj = tslib.__assign(tslib.__assign({}, res), { source: SOURCE_SERVER, ref: mutationRef, fetchTime: Date.now().toLocaleString() });
            return obj;
        });
        this._inflight.push(result);
        var removePromise = function () {
            return (_this._inflight = _this._inflight.filter(function (promise) { return promise !== result; }));
        };
        result.then(removePromise, removePromise);
        return withRefPromise;
    };
    return MutationManager;
}());
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
/**
 * Execute Mutation
 * @param mutationRef mutation to execute
 * @returns `MutationRef`
 */
function executeMutation(mutationRef) {
    return mutationRef.dataConnect._mutationManager.executeMutation(mutationRef);
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
const FIREBASE_DATA_CONNECT_EMULATOR_HOST_VAR = 'FIREBASE_DATA_CONNECT_EMULATOR_HOST';
=======
var FIREBASE_DATA_CONNECT_EMULATOR_HOST_VAR = 'FIREBASE_DATA_CONNECT_EMULATOR_HOST';
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
/**
 *
 * @param fullHost
 * @returns TransportOptions
 * @internal
 */
function parseOptions(fullHost) {
<<<<<<< HEAD
    const [protocol, hostName] = fullHost.split('://');
    const isSecure = protocol === 'https';
    const [host, portAsString] = hostName.split(':');
    const port = Number(portAsString);
    return { host, port, sslEnabled: isSecure };
=======
    var _a = fullHost.split('://'), protocol = _a[0], hostName = _a[1];
    var isSecure = protocol === 'https';
    var _b = hostName.split(':'), host = _b[0], portAsString = _b[1];
    var port = Number(portAsString);
    return { host: host, port: port, sslEnabled: isSecure };
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
}
/**
 * Class representing Firebase Data Connect
 */
<<<<<<< HEAD
class DataConnect {
    // @internal
    constructor(app, 
=======
var DataConnect = /** @class */ (function () {
    // @internal
    function DataConnect(app, 
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    // TODO(mtewani): Replace with _dataConnectOptions in the future
    dataConnectOptions, _authProvider, _appCheckProvider) {
        this.app = app;
        this.dataConnectOptions = dataConnectOptions;
        this._authProvider = _authProvider;
        this._appCheckProvider = _appCheckProvider;
        this.isEmulator = false;
        this._initialized = false;
        this._isUsingGeneratedSdk = false;
<<<<<<< HEAD
        this._callerSdkType = CallerSdkTypeEnum.Base;
        if (typeof process !== 'undefined' && process.env) {
            const host = process.env[FIREBASE_DATA_CONNECT_EMULATOR_HOST_VAR];
=======
        if (typeof process !== 'undefined' && process.env) {
            var host = process.env[FIREBASE_DATA_CONNECT_EMULATOR_HOST_VAR];
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            if (host) {
                logDebug('Found custom host. Using emulator');
                this.isEmulator = true;
                this._transportOptions = parseOptions(host);
            }
        }
    }
    // @internal
<<<<<<< HEAD
    _useGeneratedSdk() {
        if (!this._isUsingGeneratedSdk) {
            this._isUsingGeneratedSdk = true;
        }
    }
    _setCallerSdkType(callerSdkType) {
        this._callerSdkType = callerSdkType;
        if (this._initialized) {
            this._transport._setCallerSdkType(callerSdkType);
        }
    }
    _delete() {
        app._removeServiceInstance(this.app, 'data-connect', JSON.stringify(this.getSettings()));
        return Promise.resolve();
    }
    // @internal
    getSettings() {
        const copy = JSON.parse(JSON.stringify(this.dataConnectOptions));
        delete copy.projectId;
        return copy;
    }
    // @internal
    setInitialized() {
=======
    DataConnect.prototype._useGeneratedSdk = function () {
        if (!this._isUsingGeneratedSdk) {
            this._isUsingGeneratedSdk = true;
        }
    };
    DataConnect.prototype._delete = function () {
        app._removeServiceInstance(this.app, 'data-connect', JSON.stringify(this.getSettings()));
        return Promise.resolve();
    };
    // @internal
    DataConnect.prototype.getSettings = function () {
        var copy = JSON.parse(JSON.stringify(this.dataConnectOptions));
        delete copy.projectId;
        return copy;
    };
    // @internal
    DataConnect.prototype.setInitialized = function () {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        if (this._initialized) {
            return;
        }
        if (this._transportClass === undefined) {
            logDebug('transportClass not provided. Defaulting to RESTTransport.');
            this._transportClass = RESTTransport;
        }
        if (this._authProvider) {
            this._authTokenProvider = new FirebaseAuthProvider(this.app.name, this.app.options, this._authProvider);
        }
        if (this._appCheckProvider) {
<<<<<<< HEAD
            this._appCheckTokenProvider = new AppCheckTokenProvider(this.app, this._appCheckProvider);
        }
        this._initialized = true;
        this._transport = new this._transportClass(this.dataConnectOptions, this.app.options.apiKey, this.app.options.appId, this._authTokenProvider, this._appCheckTokenProvider, undefined, this._isUsingGeneratedSdk, this._callerSdkType);
=======
            this._appCheckTokenProvider = new AppCheckTokenProvider(this.app.name, this._appCheckProvider);
        }
        this._initialized = true;
        this._transport = new this._transportClass(this.dataConnectOptions, this.app.options.apiKey, this.app.options.appId, this._authTokenProvider, this._appCheckTokenProvider, undefined, this._isUsingGeneratedSdk);
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        if (this._transportOptions) {
            this._transport.useEmulator(this._transportOptions.host, this._transportOptions.port, this._transportOptions.sslEnabled);
        }
        this._queryManager = new QueryManager(this._transport);
        this._mutationManager = new MutationManager(this._transport);
<<<<<<< HEAD
    }
    // @internal
    enableEmulator(transportOptions) {
        if (this._initialized &&
            !areTransportOptionsEqual(this._transportOptions, transportOptions)) {
=======
    };
    // @internal
    DataConnect.prototype.enableEmulator = function (transportOptions) {
        if (this._initialized) {
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
            logError('enableEmulator called after initialization');
            throw new DataConnectError(Code.ALREADY_INITIALIZED, 'DataConnect instance already initialized!');
        }
        this._transportOptions = transportOptions;
        this.isEmulator = true;
<<<<<<< HEAD
    }
}
/**
 * @internal
 * @param transportOptions1
 * @param transportOptions2
 * @returns
 */
function areTransportOptionsEqual(transportOptions1, transportOptions2) {
    return (transportOptions1.host === transportOptions2.host &&
        transportOptions1.port === transportOptions2.port &&
        transportOptions1.sslEnabled === transportOptions2.sslEnabled);
}
=======
    };
    return DataConnect;
}());
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
/**
 * Connect to the DataConnect Emulator
 * @param dc Data Connect instance
 * @param host host of emulator server
 * @param port port of emulator server
 * @param sslEnabled use https
 */
<<<<<<< HEAD
function connectDataConnectEmulator(dc, host, port, sslEnabled = false) {
    // Workaround to get cookies in Firebase Studio
    if (util.isCloudWorkstation(host)) {
        void util.pingServer(`https://${host}${port ? `:${port}` : ''}`);
        util.updateEmulatorBanner('Data Connect', true);
    }
    dc.enableEmulator({ host, port, sslEnabled });
}
function getDataConnect(appOrOptions, optionalOptions) {
    let app$1;
    let dcOptions;
=======
function connectDataConnectEmulator(dc, host, port, sslEnabled) {
    if (sslEnabled === void 0) { sslEnabled = false; }
    dc.enableEmulator({ host: host, port: port, sslEnabled: sslEnabled });
}
function getDataConnect(appOrOptions, optionalOptions) {
    var app$1;
    var dcOptions;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    if ('location' in appOrOptions) {
        dcOptions = appOrOptions;
        app$1 = app.getApp();
    }
    else {
        dcOptions = optionalOptions;
        app$1 = appOrOptions;
    }
    if (!app$1 || Object.keys(app$1).length === 0) {
        app$1 = app.getApp();
    }
<<<<<<< HEAD
    const provider = app._getProvider(app$1, 'data-connect');
    const identifier = JSON.stringify(dcOptions);
    if (provider.isInitialized(identifier)) {
        const dcInstance = provider.getImmediate({ identifier });
        const options = provider.getOptions(identifier);
        const optionsValid = Object.keys(options).length > 0;
=======
    var provider = app._getProvider(app$1, 'data-connect');
    var identifier = JSON.stringify(dcOptions);
    if (provider.isInitialized(identifier)) {
        var dcInstance = provider.getImmediate({ identifier: identifier });
        var options = provider.getOptions(identifier);
        var optionsValid = Object.keys(options).length > 0;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        if (optionsValid) {
            logDebug('Re-using cached instance');
            return dcInstance;
        }
    }
    validateDCOptions(dcOptions);
    logDebug('Creating new DataConnect instance');
    // Initialize with options.
    return provider.initialize({
        instanceIdentifier: identifier,
        options: dcOptions
    });
}
/**
 *
 * @param dcOptions
 * @returns {void}
 * @internal
 */
function validateDCOptions(dcOptions) {
<<<<<<< HEAD
    const fields = ['connector', 'location', 'service'];
    if (!dcOptions) {
        throw new DataConnectError(Code.INVALID_ARGUMENT, 'DC Option Required');
    }
    fields.forEach(field => {
        if (dcOptions[field] === null || dcOptions[field] === undefined) {
            throw new DataConnectError(Code.INVALID_ARGUMENT, `${field} Required`);
=======
    var fields = ['connector', 'location', 'service'];
    if (!dcOptions) {
        throw new DataConnectError(Code.INVALID_ARGUMENT, 'DC Option Required');
    }
    fields.forEach(function (field) {
        if (dcOptions[field] === null || dcOptions[field] === undefined) {
            throw new DataConnectError(Code.INVALID_ARGUMENT, "".concat(field, " Required"));
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        }
    });
    return true;
}
/**
 * Delete DataConnect instance
 * @param dataConnect DataConnect instance
 * @returns
 */
function terminate(dataConnect) {
    return dataConnect._delete();
    // TODO(mtewani): Stop pending tasks
}

<<<<<<< HEAD
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerDataConnect(variant) {
    setSDKVersion(app.SDK_VERSION);
    app._registerComponent(new component.Component('data-connect', (container, { instanceIdentifier: settings, options }) => {
        const app = container.getProvider('app').getImmediate();
        const authProvider = container.getProvider('auth-internal');
        const appCheckProvider = container.getProvider('app-check-internal');
        let newOpts = options;
=======
function registerDataConnect(variant) {
    setSDKVersion(app.SDK_VERSION);
    app._registerComponent(new component.Component('data-connect', function (container, _a) {
        var settings = _a.instanceIdentifier, options = _a.options;
        var app = container.getProvider('app').getImmediate();
        var authProvider = container.getProvider('auth-internal');
        var appCheckProvider = container.getProvider('app-check-internal');
        var newOpts = options;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        if (settings) {
            newOpts = JSON.parse(settings);
        }
        if (!app.options.projectId) {
            throw new DataConnectError(Code.INVALID_ARGUMENT, 'Project ID must be provided. Did you pass in a proper projectId to initializeApp?');
        }
<<<<<<< HEAD
        return new DataConnect(app, { ...newOpts, projectId: app.options.projectId }, authProvider, appCheckProvider);
    }, "PUBLIC" /* ComponentType.PUBLIC */).setMultipleInstances(true));
    app.registerVersion(name, version, variant);
    // BUILD_TARGET will be replaced by values like esm, cjs, etc during the compilation
    app.registerVersion(name, version, 'cjs2020');
=======
        return new DataConnect(app, tslib.__assign(tslib.__assign({}, newOpts), { projectId: app.options.projectId }), authProvider, appCheckProvider);
    }, "PUBLIC" /* ComponentType.PUBLIC */).setMultipleInstances(true));
    app.registerVersion(name, version, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    app.registerVersion(name, version, 'cjs5');
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Execute Query
 * @param queryRef query to execute.
 * @returns `QueryPromise`
 */
function executeQuery(queryRef) {
    return queryRef.dataConnect._queryManager.executeQuery(queryRef);
}
/**
 * Execute Query
 * @param dcInstance Data Connect instance to use.
 * @param queryName Query to execute
 * @param variables Variables to execute with
 * @param initialCache initial cache to use for client hydration
 * @returns `QueryRef`
 */
function queryRef(dcInstance, queryName, variables, initialCache) {
    dcInstance.setInitialized();
    dcInstance._queryManager.track(queryName, variables, initialCache);
    return {
        dataConnect: dcInstance,
        refType: QUERY_STR,
        name: queryName,
<<<<<<< HEAD
        variables
=======
        variables: variables
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    };
}
/**
 * Converts serialized ref to query ref
 * @param serializedRef ref to convert to `QueryRef`
 * @returns `QueryRef`
 */
function toQueryRef(serializedRef) {
<<<<<<< HEAD
    const { refInfo: { name, variables, connectorConfig } } = serializedRef;
=======
    var _a = serializedRef.refInfo, name = _a.name, variables = _a.variables, connectorConfig = _a.connectorConfig;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    return queryRef(getDataConnect(connectorConfig), name, variables);
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The generated SDK will allow the user to pass in either the variable or the data connect instance with the variable,
 * and this function validates the variables and returns back the DataConnect instance and variables based on the arguments passed in.
 * @param connectorConfig
 * @param dcOrVars
 * @param vars
 * @param validateVars
 * @returns {DataConnect} and {Variables} instance
 * @internal
 */
function validateArgs(connectorConfig, dcOrVars, vars, validateVars) {
<<<<<<< HEAD
    let dcInstance;
    let realVars;
=======
    var dcInstance;
    var realVars;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    if (dcOrVars && 'enableEmulator' in dcOrVars) {
        dcInstance = dcOrVars;
        realVars = vars;
    }
    else {
        dcInstance = getDataConnect(connectorConfig);
        realVars = dcOrVars;
    }
    if (!dcInstance || (!realVars && validateVars)) {
        throw new DataConnectError(Code.INVALID_ARGUMENT, 'Variables required.');
    }
    return { dc: dcInstance, vars: realVars };
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Subscribe to a `QueryRef`
 * @param queryRefOrSerializedResult query ref or serialized result.
 * @param observerOrOnNext observer object or next function.
 * @param onError Callback to call when error gets thrown.
 * @param onComplete Called when subscription completes.
 * @returns `SubscriptionOptions`
 */
function subscribe(queryRefOrSerializedResult, observerOrOnNext, onError, onComplete) {
<<<<<<< HEAD
    let ref;
    let initialCache;
    if ('refInfo' in queryRefOrSerializedResult) {
        const serializedRef = queryRefOrSerializedResult;
        const { data, source, fetchTime } = serializedRef;
        initialCache = {
            data,
            source,
            fetchTime
=======
    var ref;
    var initialCache;
    if ('refInfo' in queryRefOrSerializedResult) {
        var serializedRef = queryRefOrSerializedResult;
        var data = serializedRef.data, source = serializedRef.source, fetchTime = serializedRef.fetchTime;
        initialCache = {
            data: data,
            source: source,
            fetchTime: fetchTime
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
        };
        ref = toQueryRef(serializedRef);
    }
    else {
        ref = queryRefOrSerializedResult;
    }
<<<<<<< HEAD
    let onResult = undefined;
=======
    var onResult = undefined;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
    if (typeof observerOrOnNext === 'function') {
        onResult = observerOrOnNext;
    }
    else {
        onResult = observerOrOnNext.onNext;
        onError = observerOrOnNext.onErr;
        observerOrOnNext.onComplete;
    }
    if (!onResult) {
        throw new DataConnectError(Code.INVALID_ARGUMENT, 'Must provide onNext');
    }
    return ref.dataConnect._queryManager.addSubscription(ref, onResult, onError, initialCache);
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
initializeFetch(fetch);
registerDataConnect('node');

<<<<<<< HEAD
exports.CallerSdkTypeEnum = CallerSdkTypeEnum;
exports.Code = Code;
exports.DataConnect = DataConnect;
exports.DataConnectError = DataConnectError;
exports.DataConnectOperationError = DataConnectOperationError;
=======
exports.DataConnect = DataConnect;
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
exports.MUTATION_STR = MUTATION_STR;
exports.MutationManager = MutationManager;
exports.QUERY_STR = QUERY_STR;
exports.SOURCE_CACHE = SOURCE_CACHE;
exports.SOURCE_SERVER = SOURCE_SERVER;
<<<<<<< HEAD
exports.areTransportOptionsEqual = areTransportOptionsEqual;
=======
>>>>>>> 7c60cf8e9581bf14c3f582da40198d0577165b3b
exports.connectDataConnectEmulator = connectDataConnectEmulator;
exports.executeMutation = executeMutation;
exports.executeQuery = executeQuery;
exports.getDataConnect = getDataConnect;
exports.mutationRef = mutationRef;
exports.parseOptions = parseOptions;
exports.queryRef = queryRef;
exports.setLogLevel = setLogLevel;
exports.subscribe = subscribe;
exports.terminate = terminate;
exports.toQueryRef = toQueryRef;
exports.validateArgs = validateArgs;
exports.validateDCOptions = validateDCOptions;
//# sourceMappingURL=index.node.cjs.js.map
